/*****************************************************************************
* File    : GC_key.ino
* Author  : 惜枫醉
* Date    : 2017/04/06
* Brief   : 按键和旋钮
*
* Copyright (c) 2000-2020 惜枫醉 All Rights Reserved.
* Remarks :修改日志
******************************************************************************/


/*****************************************************************************
*                               头文件引用
******************************************************************************/

/*****************************************************************************
*                                常量定义
******************************************************************************/


/*****************************************************************************
*                                 宏定义
******************************************************************************/


/*****************************************************************************
*                              数据类型定义
******************************************************************************/


/*****************************************************************************
*                                函数声明
******************************************************************************/


/*****************************************************************************
*                                变量定义
******************************************************************************/
static Int8 gRotrayCounter = 0;


/*****************************************************************************
* Author  : 惜枫醉
* Date    : 2017/05/28
* Brief   : 旋钮的服务，在定时器中断中每隔若干时间就会判断旋钮方向，然后计算旋钮转的格数
* Return  : 
* Remarks : 
******************************************************************************/
void KEY_rotrayWatcher_SRV(void)
{
    static char prevStat = 0;
    char assistStat = digitalRead(13);
    char curStat = digitalRead(14);
    if((curStat == LOW) && (prevStat == HIGH))
    {
        if(assistStat == HIGH)
        {
            gRotrayCounter++;
        }
        else
        {
            gRotrayCounter--;
        }
    }

    prevStat = curStat;
  
}


/*****************************************************************************
* Author  : 惜枫醉
* Date    : 2017/04/07
* Brief   : 按键初始化
* Return  : 
* Remarks : 
******************************************************************************/
void KEY_init(void)
{
    //touch button
	pinMode(4, INPUT);
  	pinMode(5, INPUT);
  	pinMode(6, INPUT);

  	//rotray
  	pinMode(15, INPUT);
    pinMode(14, INPUT);
    pinMode(13, INPUT);

    TIMER_register(2,KEY_rotrayWatcher_SRV);
}


/*****************************************************************************
* Author  : 惜枫醉
* Date    : 2017/04/06
* Brief   :  得到按键值 
* param id 按键ID 详见 KEY_Id
* Return  : 键值,普通按钮返回只是0与非0 ，0 为真 非0为未按下，旋转编码器返回当前与上一次获取时之间的差值
* Remarks : 
******************************************************************************/
Int8 KEY_get(KEY_Id id)
{
    Int8 keyValue = 0;
    static Int8 prevValue = 0;
	switch(id)
	{
		case KEY_UP:
		{
            keyValue = !digitalRead(4);
            break;
		}
		case KEY_DOWN:
		{
            keyValue = !digitalRead(6);
            break;
		}
		case KEY_STOP:
		{
            keyValue = !digitalRead(5);
            break;
		}
		case KEY_RE:
		{
            keyValue = gRotrayCounter - prevValue;
            prevValue = gRotrayCounter;
            break;
		}
		case KEY_REBT:
		{
            keyValue = digitalRead(15);
            break;
		}
		default:
		{
            keyValue = 0;
            break;
		}
	}

	return keyValue;
}


/*****************************************************************************
* Author  : 惜枫醉
* Date    : 2017/04/09
* Brief   : 检查按键超时，如果为1 则说明是长按推出，可以用来做长按检测，如果是-1则是有错误。
            如果是0则是非超时推出
* param id
* param tmOutMs
* Return  : 
* Remarks : 
******************************************************************************/
Int8 KEY_wait(KEY_Id id,Uint16 tmOutMs)
{
    delay(10);
    if(id == KEY_RE)
    {
        return -1;
    }
    if(tmOutMs == KEY_TIMEOUT_FOREVER)
    {

        while(!KEY_get(id));   
    }
    else
    {
        while((!KEY_get(id)) && (--tmOutMs))
        {
            delay(1);
        }
    }

    if(tmOutMs == 0)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}



